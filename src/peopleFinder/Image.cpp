//
// Created by jérémie on 11/12/2024.
//
#include "Image.h"

#ifndef STB_IMAGE_WRITE_IMPLEMENTATION
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb/stb_image_write.h"
#endif //STB_IMAGE_WRITE_IMPLEMENTATION

Image::Image(int width, int height, int channels, unsigned char* data) {
    this->width = width;
    this->height = height;
    this->channels = channels;
    this->data = data;
}

/**
 *
 * @param channel the channel you want to get from the image
 * @return the image grayscaled to the channel wanted
 */
Image* Image::getChannel(channel channel) {
    if (this->channels == 1) { //Image en noir et blanc
        return this;
    }
    unsigned char data[this->width * this->height];
    enum channel defChannel;
    if (this->channels == 2) { //Image en noir et blanc avec alpha
        if (channel == alpha) {
            defChannel = red;
        } else {
            defChannel = green;
        }
    } else { //Image standard
        defChannel = channel;
    }
    int iChannel;
    for (int i = 0; i < width * height; i++) {
        iChannel = i * this->channels;
        data[i] = this->data[iChannel + defChannel];
    }
    return new Image(this->width,this->height,1,data);
}

/**
 *
 * @param x the starting x point of your crop (can be negative)
 * @param y the starting y point of your crop (can be negative)
 * @param width the width of your crop
 * @param height the height of your crop
 * @return the image cropped or enlarged
 */
Image *Image::crop(int x, int y, int width, int height) {
    if (width <= 0 or height <= 0) {
        return nullptr;
    }
    unsigned char data[width * height * this->channels];

    /* setting up out of bounds */
    int oobx = 0; //Out Of Bounds X -> before picture width
    if (x < 0) {
        oobx = -x;
    }
    int oobw = 0; //Out Of Bounds W -> after picture width
    if (x + width > this->width) {
        oobw = this->width - x - width;
    }
    int ooby = 0; //Out Of Bounds Y -> before picture height
    if (y < 0) {
        ooby = -y;
    }
    int oobh = 0; //Out Of Bounds H -> after picture height
    if (y + height > this->height) {
        oobh = this->height - y - height;
    }

    int iChannel;
    int iData = 0;
    for (int oob = 0; oob < ooby; oob++) {//Black generated by default for Out Of Bounds Y
        for (int channel = 0; channel < this->channels; channel++) {
            data[iData++] = 0;
        }
    }
    for (int i = y; i < y + height; i++) {
        if (iData == width * height * channels or i > this->height) {//The crop is full or the image is out of bounds
            break;
        }
        if (y > 0) {
            for (int oob = 0; oob < oobx; oob++) {//Black generated by default for Out Of Bounds X for each line
                for (int channel = 0; channel < this->channels; channel++) {
                    data[iData++] = 0;
                }
            }
            for (int j = x; j < x + width; j++) {//the line iteration
                if (j > this->width) {//the image line is full
                    break;
                }
                if (x > 0) {
                    iChannel = (i * this->width + j) * this->channels;
                    for (int channel = 0; channel < this->channels; channel++) {
                        data[iData++] = this->data[iChannel + channel];
                    }
                }
            }
            for (int oob = 0; oob < oobw; oob++) {//Black generated by default for Out Of Bounds W for each line
                for (int channel = 0; channel < this->channels; channel++) {
                    data[iData++] = 0;
                }
            }
        }
    }
    for (int oob = 0; oob < oobh; oob++) {//Black generated by default for Out Of Bounds H
        for (int channel = 0; channel < this->channels; channel++) {
            data[iData++] = 0;
        }
    }
    return new Image(width, height, this->channels, data);
}

/**
 *
 * @param filename the filename/filepath where you want to save the image
 */
void Image::save(const char* filename) {
    if (!stbi_write_png(filename, width, height, channels, data, width * channels)) {

    }
}
